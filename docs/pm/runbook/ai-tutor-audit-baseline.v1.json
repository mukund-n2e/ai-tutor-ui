{
  "orchestrator_name": "AI Tutor UI — Baseline Audit (Step 1)",
  "version": "1.0",
  "defaults": { "shell": "bash", "stop_on_fail": true, "repo_root_required": true, "working_dir": "." },
  "steps": [
    {
      "id": "AUDIT-BASELINE-01",
      "title": "Generate Baseline Audit (design vs code vs specs). No push, no deploy.",
      "type": "agent",
      "branch": "feat/audit-baseline-01",
      "run": [
        "set -e",
        "mkdir -p .pm/artifacts/baseline scripts",
        "cat > scripts/audit-baseline.mjs << 'JS'",
        "import fs from 'fs'; import path from 'path';",
        "const root = process.cwd();",
        "const join = path.join; const exists = p => fs.existsSync(p);",
        "const SRC_APP = join(root, 'src', 'app');",
        "const STYLES = join(root, 'src', 'styles');",
        "const DESIGN = join(root, 'design');",
        "const DESIGN_SPECS = exists(join(DESIGN,'specs')) ? join(DESIGN,'specs') : (exists(join(DESIGN,'spec')) ? join(DESIGN,'spec') : null);",
        "const DESIGN_FRAMES = join(DESIGN, 'frames');",
        "const BREAKPOINTS = [360,768,1200];",
        "",
        "function walk(dir){ const out=[]; if(!exists(dir)) return out;",
        "  const stack=[dir]; while(stack.length){ const d=stack.pop();",
        "    for(const e of fs.readdirSync(d,{withFileTypes:true})){ const p=join(d,e.name);",
        "      if(e.isDirectory()) stack.push(p); else out.push(p); } } return out;}",
        "",
        "function rel(p){ return path.relative(root,p) || '.'; }",
        "",
        "// 1) Collect routes (every page.tsx + special files) -> {route, file, key}",
        "function routeToKey(route){",
        "  const parts = route.split('/').filter(Boolean);",
        "  if(parts.length===0) return 'landing';",
        "  if(parts[0]==='legal' && parts[1]==='privacy') return 'legal-privacy';",
        "  if(parts[0]==='legal' && parts[1]==='terms') return 'legal-terms';",
        "  if(parts[0]==='checkout' && parts[1]==='success') return 'checkout-success';",
        "  if(parts[0]==='checkout' && parts[1]==='error') return 'checkout-error';",
        "  if(parts[0]==='lesson' && parts.includes('outline')) return 'outline';",
        "  if(parts[0]==='not-found') return 'not-found-404';",
        "  if(parts[0]==='error') return 'error-500';",
        "  return parts[0];",
        "}",
        "function collectRoutes(){",
        "  const pages = [];",
        "  for(const p of walk(SRC_APP)){",
        "    const base = path.basename(p);",
        "    if(base==='page.tsx'){",
        "      const dir = path.dirname(p);",
        "      let relDir = path.relative(SRC_APP, dir);",
        "      let route = '/' + (relDir ? relDir.split(path.sep).join('/') : '');",
        "      pages.push({ file: p, route, key: routeToKey(route) });",
        "    }",
        "  }",
        "  if(exists(join(SRC_APP,'not-found.tsx'))) pages.push({ file: join(SRC_APP,'not-found.tsx'), route: '/not-found', key: 'not-found-404' });",
        "  if(exists(join(SRC_APP,'error.tsx'))) pages.push({ file: join(SRC_APP,'error.tsx'), route: '/error', key: 'error-500' });",
        "  return pages;",
        "}",
        "",
        "// 2) CSS modules -> keys",
        "function collectCssKeys(){",
        "  if(!exists(STYLES)) return new Set();",
        "  const files = fs.readdirSync(STYLES).filter(n=>n.endsWith('.css'));",
        "  const keys = new Set();",
        "  for(const f of files){",
        "    let k = f.replace(/\\.module\\.css$/,'').replace(/\\.css$/,'');",
        "    keys.add(k);",
        "  }",
        "  return keys;",
        "}",
        "",
        "// 3) Specs -> keys (based on filenames)",
        "function collectSpecKeys(){",
        "  const keys = new Set();",
        "  if(!DESIGN_SPECS) return keys;",
        "  for(const n of fs.readdirSync(DESIGN_SPECS)){",
        "    if(!/\\.(yml|yaml)$/i.test(n)) continue;",
        "    const base = n.replace(/\\.(yml|yaml)$/i,'');",
        "    keys.add(base);",
        "  }",
        "  return keys;",
        "}",
        "",
        "// 4) Goldens (PNGs) -> map key -> {bps:Set<number>, files:string[], folder:string}",
        "function collectDesignGoldens(){",
        "  const ignore = new Set(['frames','spec','specs','brand']);",
        "  const folders = exists(DESIGN) ? fs.readdirSync(DESIGN,{withFileTypes:true}).filter(d=>d.isDirectory() && !ignore.has(d.name)).map(d=>join(DESIGN,d.name)) : [];",
        "  const out = new Map();",
        "  const add = (key, bp, file, folder) => {",
        "    if(!out.has(key)) out.set(key,{bps:new Set(),files:[],folder});",
        "    const e = out.get(key); e.bps.add(bp); e.files.push(file);",
        "  };",
        "  for(const folder of folders){",
        "    const isSystem = path.basename(folder)==='system';",
        "    for(const p of walk(folder)){",
        "      if(!p.endsWith('.png')) continue;",
        "      const name = path.basename(p,'.png');",
        "      // expected patterns: <key>-360.png or <folder>-360.png within non-system",
        "      let key=null, bp=null;",
        "      const m = name.match(/^(.*?)-(\\d{3,4})$/);",
        "      if(m){ key = isSystem ? m[1] : (m[1].split('-')[0]); bp = parseInt(m[2],10); }",
        "      if(!key || !bp) continue;",
        "      add(key, bp, p, folder);",
        "    }",
        "  }",
        "  return out;",
        "}",
        "",
        "// 5) Token/style hygiene checks",
        "function scanFor(pattern, roots){",
        "  const hits=[]; for(const r of roots){ for(const f of walk(r)){",
        "    if(/node_modules|\\.next|playwright-report|\\.pm\\//.test(f)) continue;",
        "    const txt = fs.readFileSync(f,'utf8'); if(pattern.test(txt)) hits.push(f);",
        "  }} return hits;",
        "}",
        "",
        "const routes = collectRoutes();",
        "const cssKeys = collectCssKeys();",
        "const specKeys = collectSpecKeys();",
        "const goldens = collectDesignGoldens();",
        "",
        "// alias map to reconcile naming drift",
        "const alias = new Map([",
        "  ['pricing','pricing-checkout'],",
        "  ['pricing-checkout','pricing']",
        "]);",
        "function hasSpecFor(key){ return specKeys.has(key) || specKeys.has(alias.get(key)||''); }",
        "function cssForKey(key){",
        "  if(cssKeys.has(`${key}`)) return `${key}.module.css`;",
        "  // system pages share system.module.css",
        "  const systemish = /^(legal-|not-found|error|checkout-|account|success)/.test(key);",
        "  if(systemish && cssKeys.has('system')) return 'system.module.css';",
        "  return null;",
        "}",
        "function hasGoldens(key){ return goldens.has(key); }",
        "function goldenBps(key){ return goldens.has(key) ? Array.from(goldens.get(key).bps).sort((a,b)=>a-b) : []; }",
        "",
        "const routeKeys = new Map(); // key -> {routes:Set<string>, files:Set<string>}",
        "for(const r of routes){",
        "  if(!routeKeys.has(r.key)) routeKeys.set(r.key,{routes:new Set(), files:new Set()});",
        "  routeKeys.get(r.key).routes.add(r.route);",
        "  routeKeys.get(r.key).files.add(r.file);",
        "}",
        "",
        "const allKeys = new Set([ ...routeKeys.keys(), ...cssKeys, ...Array.from(specKeys), ...goldens.keys(), 'pricing' ]);",
        "const rows = []; const issues = [];",
        "for(const key of allKeys){",
        "  if(key==='components') continue;",
        "  const routesFor = routeKeys.get(key)?.routes || new Set();",
        "  const routeList = Array.from(routesFor).sort();",
        "  const css = cssForKey(key);",
        "  const hasSpec = hasSpecFor(key);",
        "  const hasGolden = hasGoldens(key);",
        "  const bps = goldenBps(key);",
        "  const bpOk = BREAKPOINTS.every(b=>bps.includes(b));",
        "  const row = { key, routes: routeList.join(', ') || '-', css: css||'-', spec: hasSpec ? 'yes' : 'NO', goldens: hasGolden ? 'yes' : 'NO', breakpoints: hasGolden ? (bpOk? 'OK' : `missing:${BREAKPOINTS.filter(b=>!bps.includes(b)).join(',')}`) : '-' };",
        "  rows.push(row);",
        "  // flag gaps",
        "  if(routeList.length===0 || !css || !hasSpec || !hasGolden || (hasGolden && !bpOk)){",
        "    issues.push(row);",
        "  }",
        "}",
        "",
        "// hygiene scans",
        "const inlineStyleHits = scanFor(/style=\\{\\{/g, [join(root,'src','app'), join(root,'src','components')]);",
        "const rawHexHits = scanFor(/#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\\b/g, [join(root,'src')]).filter(f=>!f.endsWith('tokens.css'));",
        "const rgbaHits = scanFor(/rgba?\\(/g, [join(root,'src')]).filter(f=>!f.endsWith('tokens.css'));",
        "",
        "const report = [];",
        "report.push(`# Baseline Audit — AI Tutor UI`);",
        "report.push('');",
        "report.push(`- src/app: ${exists(SRC_APP) ? 'present' : 'MISSING'}`);",
        "report.push(`- src/styles: ${exists(STYLES) ? 'present' : 'MISSING'}`);",
        "report.push(`- design/frames: ${exists(DESIGN_FRAMES) ? 'present' : 'MISSING'}`);",
        "report.push(`- design/specs|spec: ${DESIGN_SPECS ? 'present' : 'MISSING'}`);",
        "report.push('');",
        "report.push(`Breakpoints required: ${BREAKPOINTS.join(', ')}`);",
        "report.push('');",
        "report.push('## Coverage Table (key → route → css → spec → goldens → breakpoints)');",
        "report.push('');",
        "report.push('| key | routes | css | spec | goldens | breakpoints |');",
        "report.push('|---|---|---|:---:|:---:|---|');",
        "for(const r of rows.sort((a,b)=>a.key.localeCompare(b.key))){",
        "  report.push(`| ${r.key} | ${r.routes} | ${r.css} | ${r.spec} | ${r.goldens} | ${r.breakpoints} |`);",
        "}",
        "report.push('');",
        "report.push(`## Gaps (${issues.length})`);",
        "if(issues.length){",
        "  for(const r of issues){ report.push(`- **${r.key}** → route: ${r.routes||'-'}, css: ${r.css}, spec: ${r.spec}, goldens: ${r.goldens}, breakpoints: ${r.breakpoints}`); }",
        "} else { report.push('- None. ✅'); }",
        "report.push('');",
        "report.push('## Hygiene checks');",
        "report.push(`- Inline styles in app/components: ${inlineStyleHits.length ? 'FOUND' : 'none'}${inlineStyleHits.length? ' (see list below)':''}`);",
        "report.push(`- Raw hex colors outside tokens.css: ${rawHexHits.length ? 'FOUND' : 'none'}`);",
        "report.push(`- rgb/rgba outside tokens.css: ${rgbaHits.length ? 'FOUND' : 'none'}`);",
        "if(inlineStyleHits.length){ report.push('\\n### Inline style hits'); for(const h of inlineStyleHits) report.push('- '+rel(h)); }",
        "if(rawHexHits.length){ report.push('\\n### Raw hex color hits'); for(const h of rawHexHits) report.push('- '+rel(h)); }",
        "if(rgbaHits.length){ report.push('\\n### rgb/rgba hits'); for(const h of rgbaHits) report.push('- '+rel(h)); }",
        "",
        "const outPath = join(root,'.pm','artifacts','baseline','Baseline-Audit.md');",
        "fs.writeFileSync(outPath, report.join('\\n'), 'utf8');",
        "console.log(report.join('\\n'));",
        "if(issues.length || inlineStyleHits.length || rawHexHits.length || rgbaHits.length){",
        "  process.exitCode = 2; // fail gate but still produce report",
        "}",
        "JS",
        "node scripts/audit-baseline.mjs | tee .pm/artifacts/baseline/Baseline-Audit.md"
      ],
      "verify": [
        "test -s .pm/artifacts/baseline/Baseline-Audit.md"
      ],
      "artifacts_to_record": [
        "echo '.pm/artifacts/baseline/Baseline-Audit.md'"
      ]
    }
  ]
}
